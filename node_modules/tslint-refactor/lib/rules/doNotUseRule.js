"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tsutils_1 = require("tsutils");
var ts = require("typescript");
var Lint = require("tslint");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /* tslint:enable:object-literal-sort-keys */
    Rule.FAILURE_STRING_FACTORY = function (expression, messageAddition) {
        return "Usage of '" + expression + "' is strongly discouraged." + (messageAddition !== undefined ? " " + messageAddition : "");
    };
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new DoNotUseFunctionWalker(sourceFile, this.ruleName, parseOptions(this.ruleArguments)));
    };
    /* tslint:disable:object-literal-sort-keys */
    Rule.metadata = {
        ruleName: "do-not-use",
        description: "Prints out a warning that this function / method should not be used",
        optionsDescription: "Please check https://palantir.github.io/tslint/rules/ban/",
        options: {
            type: "list",
            listType: {
                anyOf: [
                    {
                        type: "string",
                    },
                    {
                        type: "array",
                        items: { type: "string" },
                        minLength: 1,
                        maxLength: 3,
                    },
                    {
                        type: "object",
                        properties: {
                            name: {
                                anyOf: [
                                    { type: "string" },
                                    { type: "array", items: { type: "string" }, minLength: 1 },
                                ],
                            },
                            message: { type: "string" },
                        },
                        required: ["name"],
                    },
                ],
            },
        },
        optionExamples: [
            [
                true,
                "eval",
                { name: "$", message: "please don't" },
                ["describe", "only"],
                { name: ["it", "only"], message: "don't focus tests" },
                { name: ["chai", "assert", "equal"], message: "Use 'strictEqual' instead." },
                { name: ["*", "forEach"], message: "Use a regular for loop instead." },
            ],
        ],
        type: "functionality",
        typescriptOnly: false,
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function parseOptions(args) {
    var functions = [];
    var methods = [];
    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
        var arg = args_1[_i];
        if (typeof arg === "string") {
            functions.push({ name: arg });
        }
        else if (Array.isArray(arg)) {
            switch (arg.length) {
                case 0:
                    break;
                case 1:
                    functions.push({ name: arg[0] });
                    break;
                default:
                    methods.push({ object: [arg[0]], name: arg[1], message: arg[2] });
            }
        }
        else if (!Array.isArray(arg.name)) {
            functions.push(arg);
        }
        else {
            switch (arg.name.length) {
                case 0:
                    break;
                case 1:
                    functions.push({ name: arg.name[0], message: arg.message });
                    break;
                default:
                    methods.push({ name: arg.name[arg.name.length - 1], object: arg.name.slice(0, -1), message: arg.message });
            }
        }
    }
    return { functions: functions, methods: methods };
}
var DoNotUseFunctionWalker = /** @class */ (function (_super) {
    __extends(DoNotUseFunctionWalker, _super);
    function DoNotUseFunctionWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DoNotUseFunctionWalker.prototype.walk = function (sourceFile) {
        var _this = this;
        var cb = function (node) {
            if (tsutils_1.isCallExpression(node)) {
                if (tsutils_1.isIdentifier(node.expression)) {
                    _this.checkFunctionDoNotUse(node.expression);
                }
                else if (tsutils_1.isPropertyAccessExpression(node.expression)) {
                    _this.checkForObjectMethodDoNotUse(node.expression);
                }
            }
            return ts.forEachChild(node, cb);
        };
        return ts.forEachChild(sourceFile, cb);
    };
    DoNotUseFunctionWalker.prototype.checkForObjectMethodDoNotUse = function (expression) {
        for (var _i = 0, _a = this.options.methods; _i < _a.length; _i++) {
            var ban = _a[_i];
            if (expression.name.text !== ban.name) {
                continue;
            }
            var current = expression.expression;
            for (var i = ban.object.length - 1; i > 0; --i) {
                if (!tsutils_1.isPropertyAccessExpression(current) || current.name.text !== ban.object[i]) {
                    continue;
                }
                current = current.expression;
            }
            if (ban.object[0] === "*" ||
                tsutils_1.isIdentifier(current) && current.text === ban.object[0]) {
                this.addFailureAtNode(expression, Rule.FAILURE_STRING_FACTORY(ban.object.join(".") + "." + ban.name, ban.message));
                break;
            }
        }
    };
    DoNotUseFunctionWalker.prototype.checkFunctionDoNotUse = function (name) {
        var text = name.text;
        for (var _i = 0, _a = this.options.functions; _i < _a.length; _i++) {
            var ban = _a[_i];
            if (ban.name === text) {
                this.addFailureAtNode(name, Rule.FAILURE_STRING_FACTORY(text, ban.message));
                break;
            }
        }
    };
    return DoNotUseFunctionWalker;
}(Lint.AbstractWalker));
